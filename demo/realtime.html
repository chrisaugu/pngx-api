<!DOCTYPE html>
<html>

<head>
    <title>Realtime</title>
    <link rel="stylesheet" href="assets/css/starter.css" />
</head>

<body>
    <marquee id="ticker-tape" style="background-color: rgb(255, 255, 255);"></marquee>

    <h1>Realtime</h1>
    <input type="text" id="text-view" />
    <input type="button" id="send-button" value="Send!" />
    <input type="button" id="stop-button" value="Stop" />
    <input type="button" id="start-button" value="Start" />
    </br>
    <label id="status-label">Status</label>
    <textarea id="status-log"></textarea>

    <table id="quotes-table" style="width: 100%;">
        <thead>
            <tr>
                <th>Date</th>
                <th>Symbol</th>
                <th>Bid</th>
                <th>Offer</th>
                <th>Last</th>
                <th>High</th>
                <th>Low</th>
                <th>Open</th>
                <th>Close</th>
                <th>Change</th>
                <th>Volume</th>
                <th># Trades</th>
            </tr>
        </thead>
        <!-- <tbody></tbody> -->
    </table>

    <h1>Watchlist</h1>
    <ul id="feed"></ul>

    <h1>Candlesick Chart</h1>
    <div id="candlestick" style="position: relative;"></div>
    <div id="bidoffer" style="position: relative;"></div>
    <div id="volume" style="position: relative;"></div>

    <script type="text/javascript" src="./dummy-data.js"></script>

    <script src="https://unpkg.com/lightweight-charts@5.0.5/dist/lightweight-charts.standalone.production.js"></script>

    <script type="text/javascript">
        (function () {
            const stocks = ['BSP', 'CCP', 'CGA', 'CPL', 'KAM', 'KSL', 'NEM', 'NGP', 'NIU', 'SST', 'STO'];
            const channel = "quotes,tickers,news";
            // ?channel=${channel}
            let topics = [];

            topics = ['stocks:BSP', 'stocks:CCP', 'stocks:CPL', 'stocks:KAM', 'stocks:NEM'];
            const evtSource = new EventSource(`http://localhost:5000/events?topics=${topics.join(',')}`, {
                withCredentials: true,
                headers: {
                    'Authorization': 'abc',
                    'X-Access-Token': 'abc',
                    'X-Channel': 'events',
                    'X-Topics': 'tickers:*',
                    'X-API-Version': 'v1'
                },
            });
            const feed = document.getElementById("feed");
            const log = document.getElementById('status-log');
            const tickertape = document.getElementById('ticker-tape');
            const table = document.getElementById('quotes-table');
            //     const treeWalker = document.createTreeWalker(table)

            const liMap = {};
            topics.join(',').replaceAll('stocks:', '').split(',').forEach(ticker => {
                const li = document.createElement("li");
                li.id = `stock-${ticker}`;
                li.textContent = `${ticker}: loading...`;
                feed.appendChild(li);
                liMap[ticker] = li;

                evtSource.addEventListener(`stocks:${ticker}`, e => {
                    const data = JSON.parse(e.data);
                    liMap[ticker].textContent = `${data.ticker}: K${data.price} @ ${new Date(data.timestamp).toUTCString()}`;
                });
            });

            topics = stocks.map(r => "tickers:" + r)
            const evtSource2 = new EventSource(`http://localhost:5000/events?topics=${topics.join(',')}`, {
                withCredentials: true,
                headers: {
                    'Authorization': 'abc',
                    'X-Access-Token': 'abc',
                    'X-Channel': 'events',
                    'X-Topics': 'tickers:*',
                    'X-API-Version': 'v1'
                },
            });
            const tickerTapeMap = {};
            stocks.forEach(stock => {
                const span = document.createElement("span");
                span.id = `stock-${stock}`;
                span.textContent = `${stock}: loading...`;
                tickertape.appendChild(span);
                tickerTapeMap[stock] = span;

                evtSource2.addEventListener(`tickers:${stock}`, (e) => {
                    const data = JSON.parse(e.data);
                    tickerTapeMap[stock].textContent = `${data.symbol}: K${data.open} (${Number(data.change).toFixed(0)}%) ${Number(data.change).toFixed(0) < 0.5 ? '↘️' : Number(data.change).toFixed(0) > 0.5 ? '↗️' : '➡️'} `;
                });
            });

            topics = stocks.map(r => "quotes:" + r)
            const evtSource3 = new EventSource(`http://localhost:5000/events?topics=${topics.join(',')}`, {
                withCredentials: true,
                headers: {
                    'Authorization': 'abc',
                    'X-Access-Token': 'abc',
                    'X-Channel': 'events',
                    'X-Topics': 'tickers:*',
                    'X-API-Version': 'v1'
                },
            });
            const stocklistMap = {};
            const body = document.createElement("tbody");
            table.appendChild(body);
            stocks.forEach(stock => {
                const tr = document.createElement("tr");
                tr.id = `stock-${stock}`;
                tr.textContent = `${stock}: loading...`;
                body.appendChild(tr);
                stocklistMap[stock] = tr;

                evtSource3.addEventListener(`quotes:${stock}`, (e) => {
                    const data = JSON.parse(e.data);
                    stocklistMap[stock].innerHTML = `
                        <td>${new Date(data.date).toUTCString()}</td>
                        <td>${data.code}</td>
                        <td>K${data.bid}</td>
                        <td>K${data.offer}</td>
                        <td>K${data.last}</td>
                        <td>K${data.high}</td>
                        <td>K${data.low}</td>
                        <td>K${data.open}</td>
                        <td>K${data.close}</td>
                        <td>${Number(data.chg_today).toFixed(0)}% ${Number(data.chg_today).toFixed(0) < 0 ? '↘️' : Number(data.chg_today).toFixed(0) > 0 ? '↗️' : '➡️'}</td>
                        <td>${data.vol_today}</td>
                        <td>${data.num_trades}</td>
                    `;
                });
            });

            const startLogStream = () => {
                // Create SSE connection
                const eventSource = new EventSource('http://localhost:5000/events/logs/stream');

                // Handle incoming messages
                eventSource.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    console.log('Received log:', data);
                    log.value += `${new Date(data.timestamp).toLocaleTimeString()} - ${data.message}\n`;
                };

                // Handle connection open
                // eventSource.onopen = () => {
                //     setIsConnected(true);
                // };

                // Handle errors
                eventSource.onerror = (error) => {
                    console.error('SSE error:', error);
                    // setIsConnected(false);
                    eventSource.close();
                };
            }
            // startLogStream();

            // evtSource.addEventListener('tickers', e => {
            //     const data = JSON.parse(e.data);
            // });

            //     evtSource.addEventListener(channel, (e) => {
            //         console.log("Channel update:", JSON.parse(e.data));
            //     });

            //     // news message handler
            //     evtSource.addEventListener('news', e => {
            //         console.log(`last ID: ${e.lastEventId}`);

            //         document.getElementById('headline')
            //             .textContent = e.data;

            //     });

            //     // weather message handler
            //     evtSource.addEventListener('weather', e => {

            //         const w = JSON.parse(e.data);

            //         document.getElementById('weather')
            //             .textContent = `${w.temperature} with ${w.wind} wind`;

            //     });

            //     // stock message handler
            //     evtSource.addEventListener('stock', e => {

            //         const s = JSON.parse(e.data);

            //         document.getElementById(`stock-${s.symbol}`)
            //             .textContent = `${s.share}: ${s.price} (${s.increase}%)`;

            //     });

            //     evtSource.addEventListener('error', e => {

            //         if (e.eventPhase === EventSource.CLOSED) {
            //             console.log('SSE connection closed');
            //         }
            //         else {
            //             console.log('error', e);
            //         }

            //     });

            //     evtSource.onopen = function () {
            //         console.log('connection to stream has been opened');
            //     };
            //     evtSource.onerror = function (error) {
            //         console.log('An error has occurred while receiving stream', error);
            //         evtSource.close();
            //     };
            //     evtSource.onmessage = function (stream) {
            //         console.log('received stream', stream);
            //         const parsedData = JSON.parse(stream.data);
            //         console.log(parsedData)
            //         // log.append(document.createElement('a'))

            //         const groups = Object.groupBy(parsedData, function (d) { return d.code });
            //         for (const key in groups) {
            //             let tr = document.createElement('tr');
            //             let row = groups[key].map((stock) => (`
            //                     <td>${stock.date}</td>
            //                     <td>${stock.code}</td>
            //                     <td>${stock.bid}</td>
            //                     <td>${stock.offer}</td>
            //                     <td>${stock.last}</td>
            //                     <td>${stock.high}</td>
            //                     <td>${stock.low}</td>
            //                     <td>${stock.open}</td>
            //                     <td>${stock.close}</td>
            //                     <td>${stock.chg_today}</td>
            //                     <td>${stock.vol_today}</td>
            //                     <td>${stock.num_trades}</td>
            //             `));
            //             tr.append(row)

            //             table.children.item(1).append(tr)
            //         }

            //     };

            //     function renderTable(headers, rows) {
            //         let header = ""
            //     }
        }());
    </script>

    <script>
        (function () {
            let textView = document.getElementById('text-view');
            let sendBtn = document.getElementById('send-button');
            let stopBtn = document.getElementById('stop-button');
            let startBtn = document.getElementById('start-button');
            let label = document.getElementById('status-label');
            let log = document.getElementById('status-log');

            //     const WS_URL = "ws://localhost:5000/ws/v1/stocks/quotes";
            //     const headers = ["Authorization", "abc"];

            //     // const ws = new WebSocket("wss://username:password@example.com")
            //     // the client will pull out the basic authentication access header
            //     let socket = new WebSocket(WS_URL, headers);

            //     // react
            //     // const {sendMessage, lastMessage} = useWebSocket("wss://example.com/path", {
            //     //     protocols: ["Authorization", "your_token_here"]
            //     // })

            //     if (socket.CLOSED) {
            //         log.innerHTML += "Connection closed."
            //     }
            //     if (socket.CLOSING) {
            //         log.innerHTML += "Connection closing."
            //     }
            //     if (socket.CONNECTING) {
            //         log.innerHTML += "Connection connecting."
            //     }
            //     if (socket.OPEN) {
            //         log.innerHTML += "Connection opened."
            //     }

            //     socket.onopen = function (event) {
            //         console.log("Connection established.");
            //         // Initialize any resources here and display some user-friendly
            //         // messages
            //         label.innerHTML = "Connection established!";
            //         // socket.send('ping')
            //         socket.send(JSON.stringify({
            //             'type': 'authenticate',
            //             'token': 'abc'
            //         }));
            //     };

            //     socket.onmessage = function (event) {
            //         if (typeof event.data === "string") {
            //             // If the server has sent text data, then display it.
            //             label.innerHTML += "<br />" + event.data;
            //         }
            //     };

            //     socket.onerror = function (event) {
            //         label.innerHTML = "Error: " + event;
            //     }

            //     socket.onclose = function (event) {
            //         console.log("Connection closed.");
            //         let code = event.code;
            //         let reason = event.reason;
            //         let wasClean = event.wasClean;
            //         if (wasClean) {
            //             label.innerHTML = "Connection closed normally.";
            //         } else {
            //             label.innerHTML =
            //                 "Connection closed with message " + reason + "(Code: " + code + ")";
            //         }
            //     };

            //     sendBtn.onclick = function () {
            //         // Send the data if the connection is open.
            //         if (socket.readyState === WebSocket.OPEN) {
            //             // send data to server
            //             socket.send(JSON.stringify({
            //                 'action': 'send',
            //                 'type': textView.value
            //             }));
            //         }
            //     }

            //     stopBtn.onclick = function () {
            //         // Send the data if the connection is open.
            //         if (socket.readyState === WebSocket.OPEN) {
            //             socket.close(1000, "Deliberate disconnection");
            //         }
            //     }

            //     startBtn.onclick = function () {
            //         if (socket.readyState === WebSocket.CLOSED) {
            //             socket = new WebSocket("ws://localhost:5000/ws/v1");
            //         }
            //     }
        }())
    </script>

    <script type="text/javascript">
            (function () {
                const chartOptions = {
                    layout: {
                        textColor: 'black',
                        background: { type: 'solid', color: 'white' },
                    },
                    width: 800,
                    height: 300
                };

                const container = document.getElementById('candlestick');
                const chart = LightweightCharts.createChart(container, chartOptions);
                chart.applyOptions({
                    crosshair: {
                        // hide the horizontal crosshair line
                        horzLine: {
                            visible: false,
                            labelVisible: false,
                        },
                        // hide the vertical crosshair label
                        vertLine: {
                            labelVisible: false,
                        },
                    },
                    // hide the grid lines
                    grid: {
                        vertLines: {
                            visible: false,
                        },
                        horzLines: {
                            visible: false,
                        },
                    },
                });

                let ticker = "NCM";
                let stocksGroup = Object.groupBy(quotesData, (e) => e.symbol);
                // console.log(stocksGroup)
                let candleData = stocksGroup[ticker].slice(0, 25).map(d => ({
                    open: d.open,
                    high: d.high,
                    low: d.low,
                    close: d.close,
                    time: d.date
                }));
                // console.log(candleData)
                let volumeData = stocksGroup[ticker].slice(0, 25).map(d => ({
                    value: d.volume,
                    time: d.date
                }));
                // console.log(volumeData)
                let bidData = stocksGroup[ticker].slice(0, 25).map(d => ({
                    value: d.bid,
                    time: d.date
                }));
                // console.log(bidData)

                // Only needed within demo page
                // eslint-disable-next-line no-undef
                window.addEventListener('resize', () => {
                    chart.applyOptions({ height: 200 });
                });

                //             const intervalColors = {
                //                 '1D': '#2962FF',
                //                 '1W': 'rgb(225, 87, 90)',
                //                 '1M': 'rgb(242, 142, 44)',
                //                 '1Y': 'rgb(164, 89, 209)',
                //             };

                //             // bid and offer
                //             const lineSeries = chart.addSeries(LightweightCharts.LineSeries, { color: intervalColors['1D'] });
                //             lineSeries.setData([
                //                 { time: '2019-04-11', value: 80.01 },
                //                 { time: '2019-04-12', value: 96.63 },
                //                 { time: '2019-04-13', value: 76.64 },
                //                 { time: '2019-04-14', value: 81.89 },
                //                 { time: '2019-04-15', value: 74.43 },
                //                 { time: '2019-04-16', value: 80.01 },
                //                 { time: '2019-04-17', value: 96.63 },
                //                 { time: '2019-04-18', value: 76.64 },
                //                 { time: '2019-04-19', value: 81.89 },
                //                 { time: '2019-04-20', value: 74.43 },
                //             ]);

                //             function setChartInterval(interval) {
                //                 lineSeries.setData(seriesesData.get(interval));
                //                 lineSeries.applyOptions({
                //                     color: intervalColors[interval],
                //                 });
                //                 chart.timeScale().fitContent();
                //             }

                //             setChartInterval('1D');

                //             const buttonsContainer = document.createElement('div');
                //             buttonsContainer.classList.add('buttons-container');
                //             const intervals = ['1D', '1W', '1M', '1Y'];
                //             intervals.forEach(interval => {
                //                 const button = document.createElement('button');
                //                 button.innerText = interval;
                //                 button.addEventListener('click', () => setChartInterval(interval));
                //                 buttonsContainer.appendChild(button);
                //             });

                //             container.appendChild(buttonsContainer);

                // volume traded
                const areaSeries = chart.addSeries(LightweightCharts.AreaSeries, {
                    lineColor: '#2962FF',
                    topColor: '#2962FF',
                    bottomColor: 'rgba(41, 98, 255, 0.28)',
                    lineWidth: 2,
                    crossHairMarkerVisible: false,
                });
                areaSeries.priceScale().applyOptions({
                    scaleMargins: {
                        top: 0.3, // leave some space for the legend
                        bottom: 0.25,
                    },
                });
                areaSeries.setData(volumeData);

                const toolTipWidth = 80;
                const toolTipHeight = 80;
                const toolTipMargin = 15;

                // Create and style the tooltip html element
                const toolTip = document.createElement('div');
                toolTip.style = `width: 96px; height: 80px; position: absolute; display: none; padding: 8px; box-sizing: border-box; font-size: 12px; text-align: left; z-index: 1000; top: 12px; left: 12px; pointer-events: none; border: 1px solid; border-radius: 2px;font-family: -apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;`;
                toolTip.style.background = 'white';
                toolTip.style.color = 'black';
                toolTip.style.borderColor = '#2962FF';
                container.appendChild(toolTip);

                // update tooltip
                chart.subscribeCrosshairMove(param => {
                    if (
                        param.point === undefined ||
                        !param.time ||
                        param.point.x < 0 ||
                        param.point.x > container.clientWidth ||
                        param.point.y < 0 ||
                        param.point.y > container.clientHeight
                    ) {
                        toolTip.style.display = 'none';
                    } else {
                        // time will be in the same format that we supplied to setData.
                        // thus it will be YYYY-MM-DD
                        const dateStr = param.time;
                        toolTip.style.display = 'block';
                        const data = param.seriesData.get(areaSeries);
                        const price = data.value !== undefined ? data.value : data.close;
                        toolTip.innerHTML = `<div style="color: ${'#2962FF'}">${ticker}</div><div style="font-size: 24px; margin: 4px 0px; color: ${'black'}">
                                        ${Math.round(100 * price) / 100}
                                        </div><div style="color: ${'black'}">
                                        ${dateStr}
                                        </div>`;

                        const coordinate = areaSeries.priceToCoordinate(price);
                        let shiftedCoordinate = param.point.x - 50;
                        if (coordinate === null) {
                            return;
                        }
                        shiftedCoordinate = Math.max(
                            0,
                            Math.min(container.clientWidth - toolTipWidth, shiftedCoordinate)
                        );
                        const coordinateY =
                            coordinate - toolTipHeight - toolTipMargin > 0
                                ? coordinate - toolTipHeight - toolTipMargin
                                : Math.max(
                                    0,
                                    Math.min(
                                        container.clientHeight - toolTipHeight - toolTipMargin,
                                        coordinate + toolTipMargin
                                    )
                                );
                        toolTip.style.left = shiftedCoordinate + 'px';
                        toolTip.style.top = coordinateY + 'px';
                    }
                })

                chart.subscribeClick(param => {
                    console.log(param)
                })
                // candlestick
                const candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderVisible: false,
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                });
                // candlestickSeries.setData(tickerData);
                // candlestickSeries.setData(candleData);

                // candlestickSeries.applyOptions({
                //     upColor: 'red',
                //     downColor: 'blue',
                // });

                const lineSeries = chart.addSeries(LightweightCharts.LineSeries);
                lineSeries.setData(bidData);

                function calculateMovingAverageSeriesData(candleData, maLength) {
                    const maData = [];

                    for (let i = 0; i < candleData.length; i++) {
                        if (i < maLength) {
                            // Provide whitespace data points until the MA can be calculated
                            maData.push({ time: candleData[i].time });
                        } else {
                            // Calculate the moving average, slow but simple way
                            let sum = 0;
                            for (let j = 0; j < maLength; j++) {
                                sum += candleData[i - j].close;
                            }
                            const maValue = sum / maLength;
                            maData.push({ time: candleData[i].time, value: maValue });
                        }
                    }

                    return maData;
                }

                // const barSeries = chart.addSeries(LightweightCharts.BarSeries, { upColor: '#26a69a', downColor: '#ef5350' });
                // const maData = calculateMovingAverageSeriesData(tickerData, 20);

                // barSeries.setData(tickerData);
                // const maSeries = chart.addSeries(LightweightCharts.LineSeries, { color: '#2962FF', lineWidth: 1 });
                // maSeries.setData(maData);

                const baselineSeries = chart.addSeries(LightweightCharts.BaselineSeries, {
                    baseValue: { type: 'price', price: 25 },
                    topLineColor: 'rgba( 38, 166, 154, 1)',
                    topFillColor1: 'rgba( 38, 166, 154, 0.28)',
                    topFillColor2: 'rgba( 38, 166, 154, 0.05)',
                    bottomLineColor: 'rgba( 239, 83, 80, 1)',
                    bottomFillColor1: 'rgba( 239, 83, 80, 0.05)',
                    bottomFillColor2: 'rgba( 239, 83, 80, 0.28)'
                });
                // baselineSeries.setData(dayData);

                function addData(chart, label, newData) {
                    // Update the most recent bar
                    // areaSeries.update({ time: '2018-12-31', value: 25 });
                    // candlestickSeries.update({ time: '2018-12-31', open: 109.87, high: 114.69, low: 85.66, close: 112 });

                    // Creating the new bar
                    // areaSeries.update({ time: '2019-01-01', value: 20 });
                    // candlestickSeries.update({ time: '2019-01-01', open: 112, high: 112, low: 100, close: 101 });
                }

                function removeData(chart) {
                }

                //             const series = chart.addSeries(LightweightCharts.CandlestickSeries, {
                //                 upColor: '#26a69a',
                //                 downColor: '#ef5350',
                //                 borderVisible: false,
                //                 wickUpColor: '#26a69a',
                //                 wickDownColor: '#ef5350',
                //             });
                //             let randomFactor = 25 + Math.random() * 25;
                //             const samplePoint = i =>
                //                 i *
                //                 (0.5 +
                //                     Math.sin(i / 1) * 0.2 +
                //                     Math.sin(i / 2) * 0.4 +
                //                     Math.sin(i / randomFactor) * 0.8 +
                //                     Math.sin(i / 50) * 0.5) +
                //                 200 +
                //                 i * 2;

                //             function generateData(
                //                 numberOfCandles = 500,
                //                 updatesPerCandle = 5,
                //                 startAt = 100
                //             ) {
                //                 const createCandle = (val, time) => ({
                //                     time,
                //                     open: val,
                //                     high: val,
                //                     low: val,
                //                     close: val,
                //                 });

                //                 const updateCandle = (candle, val) => ({
                //                     time: candle.time,
                //                     close: val,
                //                     open: candle.open,
                //                     low: Math.min(candle.low, val),
                //                     high: Math.max(candle.high, val),
                //                 });

                //                 randomFactor = 25 + Math.random() * 25;
                //                 const date = new Date(Date.UTC(2018, 0, 1, 12, 0, 0, 0));
                //                 const numberOfPoints = numberOfCandles * updatesPerCandle;
                //                 const initialData = [];
                //                 const realtimeUpdates = [];
                //                 let lastCandle;
                //                 let previousValue = samplePoint(-1);
                //                 for (let i = 0; i < numberOfPoints; ++i) {
                //                     if (i % updatesPerCandle === 0) {
                //                         date.setUTCDate(date.getUTCDate() + 1);
                //                     }
                //                     const time = date.getTime() / 1000;
                //                     let value = samplePoint(i);
                //                     const diff = (value - previousValue) * Math.random();
                //                     value = previousValue + diff;
                //                     previousValue = value;
                //                     if (i % updatesPerCandle === 0) {
                //                         const candle = createCandle(value, time);
                //                         lastCandle = candle;
                //                         if (i >= startAt) {
                //                             realtimeUpdates.push(candle);
                //                         }
                //                     } else {
                //                         const newCandle = updateCandle(lastCandle, value);
                //                         lastCandle = newCandle;
                //                         if (i >= startAt) {
                //                             realtimeUpdates.push(newCandle);
                //                         } else if ((i + 1) % updatesPerCandle === 0) {
                //                             initialData.push(newCandle);
                //                         }
                //                     }
                //                 }

                //                 return {
                //                     initialData,
                //                     realtimeUpdates,
                //                 };
                //             }
                //             const data = generateData(2500, 20, 1000);

                //             series.setData(data.initialData);
                //             chart.timeScale().fitContent();
                //             chart.timeScale().scrollToPosition(5);

                //             // simulate real-time data
                //             function* getNextRealtimeUpdate(realtimeData) {
                //                 for (const dataPoint of realtimeData) {
                //                     yield dataPoint;
                //                 }
                //                 return null;
                //             }
                //             const streamingDataProvider = getNextRealtimeUpdate(data.realtimeUpdates);

                //             const intervalID = setInterval(() => {
                //                 const update = streamingDataProvider.next();
                //                 if (update.done) {
                //                     clearInterval(intervalID);
                //                     return;
                //                 }
                //                 series.update(update.value);
                //             }, 100);

                //             const buttonsContainer = document.createElement('div');
                //             buttonsContainer.classList.add('buttons-container');
                //             const button = document.createElement('button');
                //             button.innerText = 'Go to realtime';
                //             button.addEventListener('click', () => chart.timeScale().scrollToRealTime());
                //             buttonsContainer.appendChild(button);
                //             container.appendChild(buttonsContainer);

                // chart.timeScale().fitContent();
                chart.timeScale().subscribeVisibleLogicalRangeChange(logicalRange => {
                    if (logicalRange.from < 10) {
                        // load more data
                        const numberBarsToLoad = 50 - logicalRange.from;
                        // const data = datafeed.getBars(numberBarsToLoad);
                        // console.log(numberBarsToLoad)
                        setTimeout(() => {
                            // series.setData(data);
                        }, 250); // add a loading delay
                    }
                });

                const chartOptions2 = {
                    autoSize: true,
                    layout: {
                        textColor: 'black',
                        background: { type: 'solid', color: 'white' },
                    },
                    yieldCurve: {
                        baseResolution: 12,
                        minimumTimeRange: 10,
                        startTimeRange: 3,
                    },
                    handleScroll: false,
                    handleScale: false,
                    grid: {
                        vertLines: {
                            visible: false,
                        },
                        horzLines: {
                            visible: false,
                        },
                    },
                    timeScale: {
                        minBarSpacing: 3,
                    },
                };
                // const chart2 = LightweightCharts.createYieldCurveChart(container, chartOptions2);
                // const curve1 = [
                //     { time: 1, value: 5.378 },
                //     { time: 2, value: 5.372 },
                //     { time: 3, value: 5.271 },
                //     { time: 6, value: 5.094 },
                //     { time: 12, value: 4.739 },
                //     { time: 24, value: 4.237 },
                //     { time: 36, value: 4.036 },
                //     { time: 60, value: 3.887 },
                //     { time: 84, value: 3.921 },
                //     { time: 120, value: 4.007 },
                //     { time: 240, value: 4.366 },
                //     { time: 360, value: 4.29 },
                // ];
                // const curve2 = [
                //     { time: 1, value: 5.381 },
                //     { time: 2, value: 5.393 },
                //     { time: 3, value: 5.425 },
                //     { time: 6, value: 5.494 },
                //     { time: 12, value: 5.377 },
                //     { time: 24, value: 4.883 },
                //     { time: 36, value: 4.554 },
                //     { time: 60, value: 4.241 },
                //     { time: 84, value: 4.172 },
                //     { time: 120, value: 4.084 },
                //     { time: 240, value: 4.365 },
                //     { time: 360, value: 4.176 },
                // ];

                // const series1 = chart2.addSeries(LightweightCharts.LineSeries, {
                //     lineType: 2,
                //     color: '#26c6da',
                //     pointMarkersVisible: true,
                //     lineWidth: 2,
                // });
                // const priceChangeMarkers = LightweightCharts.createUpDownMarkers(series1);
                // priceChangeMarkers.setData(curve1);

                // const series2 = chart2.addSeries(LightweightCharts.LineSeries, {
                //     lineType: 2,
                //     color: 'rgb(164, 89, 209)',
                //     pointMarkersVisible: true,
                //     lineWidth: 1,
                // });
                // series2.setData(curve2);

                // chart2.timeScale().fitContent();

                // chart2.timeScale().subscribeSizeChange(() => {
                //     chart2.timeScale().fitContent();
                // });

                // setInterval(() => {
                //     curve1
                //         .filter(() => Math.random() < 0.1)
                //         .forEach(data => {
                //             const shift = (Math.random() > 0.5 ? -1 : 1) * Math.random() * 0.01 * data.value;
                //             priceChangeMarkers.update(
                //                 {
                //                     ...data,
                //                     value: data.value + shift,
                //                 },
                //                 true
                //             );
                //         });
                // }, 5000);
            }())
    </script>
</body>

</html>